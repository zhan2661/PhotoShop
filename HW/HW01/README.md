# 3081 HW01 C++ Class Basics

## What You Will Learn
1. How to retrieve new class materials and merge them into your repository
2. How to build a simple C++ class, compile and execute it.
3. [OPTIONAL] How to execute unit tests against your program using Google Test

### Retrieve class materials and merge into your personal repository

Navigate to your repository.

    % cd <path_to_your_repository's_root_folder>

Now, we want to get the new class materials from the shared-upstream. To do that,
we need to pull them into our _support-code_ branch. At the end of the last homework,
you likely are still in the _master_ branch. To confirm this, execute the _git status_ command.

    % git status
	
The output should begin with the branch you are currently on. If it says _On branch support-code_,
you're all set. That's where we're going. If you are still in _master_, execute this command to switch to the _support-code_ branch.

    % git checkout support-code

**_What just happened?_** If you run the above command, you "switch" into the _support-code_ branch.
This means that git changes the filesystem to represent the state of files under the _support-code_ branch.
This could mean deleting files, adding files, or changing files, depending on how different the files in _master_
are from the files in _support-code_. Since you were working in _master_ on your HW00 deliverable, there should be some minor changes when we switch to _support-code_.

Now that we are in _support-code_, let's check for updates from the shared-upstream repository.

    % git pull upstream support-code

**_What just happened?_** You pulled the files from our csci3081-shared-upstream repository's 
_support-code_ branch into your **local** repository's _support-code_ branch. Anything new in the 
shared-upstream repo is now a part of your local repo in this branch.

** Why didn't we do _git pull_? ** The default command in the Git workflow would indeed be _git pull_. However, that command uses the default target _origin_. For our work, _origin_ is the target for your remote repository, repo-<your_id> residing on the github.umn.edu server. We set up csci3081-shared-upstream as a secondary remote target repository, with the name of _upstream_. To complete the pull action for that repo, we need to add the target name to the _git pull_ command.

Now that we have the updates from our shared-upstream, let's add them into our own work in the _master_ branch.

    % git checkout master
	% git merge support-code
	
**_What just happened?_** You changed back to having the _master_ branch as your working project. You then merged the file contents and commit history from _support-code_ to _master_. This adds the changes to our shared-upstream repo into your working branch _master_. 

** Why do we have support-code? ** Technically, we could issue a command that takes these changes and merges them directly into _master_, without having to deal with our own local _support-code_ branch. That's true, and we could do that. But, we wanted to 
    A) make sure that students maintain a clean copy of the provided code on their local machine. If you make a mistake in your _master_ branch, having the clean copy may be beneficial.
	B) give you practice in handling merges, since that will be a beneficial skill to have when we start making more complex branching structures during the project.

### What's in HW/HW01?

	* main.cpp
	
	This contains the basic main function which will exercise the Point2 class, which you will build as part of this lab. It contains a relatively basic means of ensuring that Point2 is working.
	
	* Makefile
	
	This makefile is provided to allow you to easily build the executable to run this program, assuming you've created a proper point2.h and point2.cc set of files. It also provides for a _clean_ target, to ease removal of the resulting files generated by the build process.
	
	* README.md
	
	Your reading this now.
	
	* Makefile.grader
	* point2_unittest.cc
	
	These two files are provided in case you'd like to make use of the Google Test framework and execute the unit tests against your code manually. Pushing your code to your remote repository does this for you, through the automated feedback mechanism. But, in case you'd like to get started running your own unit tests on your code, an optional section of this homework helps you do just that. These files are part of that optional section.
	
### Building the class Point2

The primary goal of this homework is to build a simple C++ class to fulfill the interface as exhibited in the provided _main.cpp_ file. Review _main.cpp_ now and determine what constructors and methods would be necessary for your Point2 class to work properly.

The most vague part of this interface is the method _DistanceBetween()_. Notice its arguments and its invocation. There isn't much to go on here as to how the method actually works. So, let's define that for ourselves.

The nominal distance between two points is given by the formula

![](https://github.umn.edu/umn-csci-3081-F18/csci3081-instructors/blob/support-code/HW/HW01/distance_formula.png)

The method should return the distance between the two points: the point with which the method is invoked and the point which is passed as an argument.
	
### Executing Lab Code and Pushing Results

The code provided for HW01 will create an executable by compiling the provided
C++ files using a _makefile_. The resulting executable, hw01.out, should be created if your point2.h and point2.cc files do not cause syntax errors.

If necessary, change directories to the HW/HW01 directory.

    % cd HW/HW01

Build the executable using the makefile

	% make

**_What just happened?_** You made _HW/HW01_ your working directory with `cd`. You
executed the makefile (named _makefile_) with `make`, which created the executable _hw01.out_. 

    % ./hw01.out

**_What just happened?_** You ran the executable with `./hw01.out`.

Did the output match your expected results? If so, you are ready to push your changes to your remote repository for automated feedback. If not, debug your program locally until it is working properly.

### [OPTIONAL] Use the Google Test framework to verify your programs correctness

You may or may not have noticed another directory that was downloaded when you pulled the latest updates from the shared-upstream. The googletest directory includes a variety of files which enables you to build the google test framework and utilize it to execute unit tests against your codebase. These tests are helpful in ensuring that your code is working as expected. This directory, in conjunction with the Makefile.grader and point2_unittest.cc file, can be used to evaluate your program locally, just as the grading script will do on the grading server.

If you wish, you can make use of the framework now. To do so, you need to merely replace the existing makefile with the grader version.

    % mv Makefile Makefile.student
	
**_What just happened?_** renamed the Makefile as Makefile.student. This isn't strictly necessary, but it is nice to keep a copy of the original makefile in case you'd like to revert back to it.

    % cp Makefile.grader Makefile
	
**_What just happened?_** renamed Makefile.grader to Makefile to allow it to be used when _make_ is executed. Again, we could have moved/renamed the file, but let's keep a copy around.

    % make

**_What just happened?_** Built the Google Test framework objects and ran our unit tests (point2_unittest) against our complied code. 

    % ./point2_unittest
	
**_What just happened?_** Executes the unit tests and displays the testing results. If all goes well, you should see the tests run and pass (in green text). Otherwise, you'll see some tests fail and get the dreaded red text.

Again, once you're satisfied in your program's correctness, it's time to submit your work. But, one last task first: making sure no additional files are being pushed.

    % git status
	
This should list all the files that have changed and/or are untracked. As long as the other files listed are the two files you added for the Point2 class (point2.h and point2.cc), you're good to go!  If other files are also listed as being ready to stage for commit, you may need to update your .gitignore to make sure we don't push files that we shouldn't be committing. Once you're ready to commit just point2.h and point2.cc, continue to the next section.

### Add Changes to Repo both Locally and on the Server

[This text is the same as in the previous homework.] You need to _stage_ all changes to the repository, which prepares those items to
be permanently part of the repository. When you _commit_ those changes, they are
saved to your local repository, which lives in your cselabs account (or your
personal computer if that is what you are working on). When you _push_ those
changes, they will be copied to the repo on the server. The difference between
_commit_ and _push_ is what separates git from centralized version control
systems.

    % git status
    % git add -A
    % git commit -m "add(HW01): Adding HW01 deliverables"
    % git push

**_What just happened?_** Double-checking the files to be staged using the _git status_ command. All of the tracked changes are staged with `git add -A`. Those staged changes were committed to your local repository and tagged with the message that follows `-m`, then pushed to the server in your remote repository.

### Reading the Feedback

Pushing to the server triggers the automated grading system. Soon your repo will
contain a feedback file, letting you know if you have passed all tests of the
assignment. 

    % git pull

THIS HOMEWORK IS COMPLETE.

Congratulations!

[1]: /distance_formula.png "Distance between two points (x1,y1) and (x2,y2) is calculated by taking the square root of x2 - x1, squared plus y2-y1, squared."
